<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>HTTP_cpp: HTTPClient 클래스 참조</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HTTP_cpp
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 다음에 의해 생성됨 :  Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'검색');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>메인&#160;페이지</span></a></li>
      <li class="current"><a href="annotated.html"><span>클래스</span></a></li>
      <li><a href="files.html"><span>파일들</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="검색" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>클래스&#160;목록</span></a></li>
      <li><a href="classes.html"><span>클래스&#160;색인</span></a></li>
      <li><a href="functions.html"><span>클래스&#160;멤버</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_h_t_t_p_client.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>모두</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>클래스</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>파일들</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>함수</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>변수</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>타입정의</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>열거형 타입</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>열거형 멤버</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>매크로</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>페이지들</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 멤버 함수</a> &#124;
<a href="#pri-methods">Private 멤버 함수</a> &#124;
<a href="#pri-static-methods">정적 Private 멤버 함수</a> &#124;
<a href="#pri-attribs">Private 속성</a>  </div>
  <div class="headertitle">
<div class="title">HTTPClient 클래스 참조</div>  </div>
</div><!--header-->
<div class="contents">

<p>내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.  
 <a href="class_h_t_t_p_client.html#details">더 자세히 ...</a></p>

<p><code>#include &lt;<a class="el" href="_h_t_t_p_client_8h_source.html">HTTPClient.h</a>&gt;</code></p>

<p><a href="class_h_t_t_p_client-members.html">모든 멤버 목록</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public 멤버 함수</h2></td></tr>
<tr class="memitem:a26860227a4605fc5be92e2cb38486f7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a26860227a4605fc5be92e2cb38486f7c">HTTPClient</a> (<a class="el" href="class_h_t_t_p_event.html">HTTPEvent</a> *_event, const std::string _tag, const <a class="el" href="class_h_t_t_p_request.html">HTTPRequest</a> _request)</td></tr>
<tr class="memdesc:a26860227a4605fc5be92e2cb38486f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">생성자  <a href="#a26860227a4605fc5be92e2cb38486f7c"></a><br/></td></tr>
<tr class="memitem:a97467b9bd9469200fb5266ae3622acc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a97467b9bd9469200fb5266ae3622acc2">~HTTPClient</a> ()</td></tr>
<tr class="memdesc:a97467b9bd9469200fb5266ae3622acc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">소멸자  <a href="#a97467b9bd9469200fb5266ae3622acc2"></a><br/></td></tr>
<tr class="memitem:ab435bd9c4485fb2d8860d821e598b27d"><td class="memItemLeft" align="right" valign="top">CURL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ab435bd9c4485fb2d8860d821e598b27d">GetCURL</a> ()</td></tr>
<tr class="memdesc:ab435bd9c4485fb2d8860d821e598b27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">libcurl 인스턴스를 가져오는 함수입니다.  <a href="#ab435bd9c4485fb2d8860d821e598b27d"></a><br/></td></tr>
<tr class="memitem:ad2e70df1d9aa350e6666808d56d74ff2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ad2e70df1d9aa350e6666808d56d74ff2">GetTag</a> ()</td></tr>
<tr class="memdesc:ad2e70df1d9aa350e6666808d56d74ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">어떤요청에 대한 응답인가를 구분하기위한 태그를 가져오기위한 함수입니다.  <a href="#ad2e70df1d9aa350e6666808d56d74ff2"></a><br/></td></tr>
<tr class="memitem:a11a02d3946f51d593310d0c529621d25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a11a02d3946f51d593310d0c529621d25">Pause</a> ()</td></tr>
<tr class="memdesc:a11a02d3946f51d593310d0c529621d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">연결을 일시중지 합니다.  <a href="#a11a02d3946f51d593310d0c529621d25"></a><br/></td></tr>
<tr class="memitem:ace4da074eb433e490c291fcbf5ca76c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ace4da074eb433e490c291fcbf5ca76c2">Resume</a> ()</td></tr>
<tr class="memdesc:ace4da074eb433e490c291fcbf5ca76c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">연결을 일시중지상태에서 빠져나옵니다.  <a href="#ace4da074eb433e490c291fcbf5ca76c2"></a><br/></td></tr>
<tr class="memitem:a7bb2704835eb0fc23b714a5e0ce76fc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a7bb2704835eb0fc23b714a5e0ce76fc4">PrevUpdateAndGetNeedDelete</a> ()</td></tr>
<tr class="memdesc:a7bb2704835eb0fc23b714a5e0ce76fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">이함수는 <a class="el" href="class_h_t_t_p_manager.html#a688eb551b475720abf1e3643a40c74fa" title="HTTPEvent 요청에 대한 응답을 기다리고 응답이 있으면 처리합니다.">HTTPManager::Update</a> 때 필요한 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 의 작동을 위한 함수입니다.  <a href="#a7bb2704835eb0fc23b714a5e0ce76fc4"></a><br/></td></tr>
<tr class="memitem:a292f406c40b3d2ccaf91b83fe9a3616c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a292f406c40b3d2ccaf91b83fe9a3616c">MessageReciever</a> (CURLcode _code)</td></tr>
<tr class="memdesc:a292f406c40b3d2ccaf91b83fe9a3616c"><td class="mdescLeft">&#160;</td><td class="mdescRight">응답이 처리된 결과를 <a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> (개발자가 생성한 클래스) 에게 전달하는 함수입니다.  <a href="#a292f406c40b3d2ccaf91b83fe9a3616c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-methods"></a>
Private 멤버 함수</h2></td></tr>
<tr class="memitem:a5c4bbb32ffa729f09442597b70655d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a5c4bbb32ffa729f09442597b70655d9b">ReadyFile</a> ()</td></tr>
<tr class="memdesc:a5c4bbb32ffa729f09442597b70655d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">인스턴스를 생성할때 호출되는 파일스트림 준비함수 입니다.  <a href="#a5c4bbb32ffa729f09442597b70655d9b"></a><br/></td></tr>
<tr class="memitem:a71aba6342097c8901d0f23deec079386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a71aba6342097c8901d0f23deec079386">ReadyHeader</a> ()</td></tr>
<tr class="memdesc:a71aba6342097c8901d0f23deec079386"><td class="mdescLeft">&#160;</td><td class="mdescRight">인스턴스를 생성할때 호출되는 요청해더 준비함수 입니다.  <a href="#a71aba6342097c8901d0f23deec079386"></a><br/></td></tr>
<tr class="memitem:a036d48e160ef6b9ec60f53a27e71efde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a036d48e160ef6b9ec60f53a27e71efde">ReadyBody</a> ()</td></tr>
<tr class="memdesc:a036d48e160ef6b9ec60f53a27e71efde"><td class="mdescLeft">&#160;</td><td class="mdescRight">인스턴스를 생성할때 호출되는 요청바디 준비함수 입니다.  <a href="#a036d48e160ef6b9ec60f53a27e71efde"></a><br/></td></tr>
<tr class="memitem:afd834a35837d4fdf7a8aef71b545363c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#afd834a35837d4fdf7a8aef71b545363c">UpdateDB</a> ()</td></tr>
<tr class="memdesc:afd834a35837d4fdf7a8aef71b545363c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqlite 데이터베이스를 업데이트하는 함수입니다.  <a href="#afd834a35837d4fdf7a8aef71b545363c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-static-methods"></a>
정적 Private 멤버 함수</h2></td></tr>
<tr class="memitem:a32acff1743076dcf79a8a652a37a4afa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a32acff1743076dcf79a8a652a37a4afa">SQLMatchURLCallback</a> (void *_reference, int _field_length, char **_field, char **_field_name)</td></tr>
<tr class="memdesc:a32acff1743076dcf79a8a652a37a4afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">보내려는 요청값과 같은 이전요청(같은 URL)이 있나를 검색하는 sqlite콜백  <a href="#a32acff1743076dcf79a8a652a37a4afa"></a><br/></td></tr>
<tr class="memitem:a9bbd082e51409e3bfe75cbf6d85c4a74"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a9bbd082e51409e3bfe75cbf6d85c4a74">ReadBody</a> (char *_stream, size_t _size, size_t _count, void *_pointer)</td></tr>
<tr class="memdesc:a9bbd082e51409e3bfe75cbf6d85c4a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답의 바디를 저장하는 콜백함수  <a href="#a9bbd082e51409e3bfe75cbf6d85c4a74"></a><br/></td></tr>
<tr class="memitem:a0c2611e4df1de68e2b556d07a39bdc11"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a0c2611e4df1de68e2b556d07a39bdc11">ReadHeader</a> (char *_stream, size_t _size, size_t _count, void *_pointer)</td></tr>
<tr class="memdesc:a0c2611e4df1de68e2b556d07a39bdc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답의 헤더를 저장하는 콜백함수  <a href="#a0c2611e4df1de68e2b556d07a39bdc11"></a><br/></td></tr>
<tr class="memitem:a42a26707682633205202d0916ece0102"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a42a26707682633205202d0916ece0102">Progress</a> (void *_client_pointer, double _download_total, double _download_now, double _upload_total, double _upload_now)</td></tr>
<tr class="memdesc:a42a26707682633205202d0916ece0102"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청 또는 응답의 진행상태를 가져오는 콜백함수  <a href="#a42a26707682633205202d0916ece0102"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pri-attribs"></a>
Private 속성</h2></td></tr>
<tr class="memitem:a5c4373e43d9720c8ad8feec3743ba66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_t_t_p_response.html#af2cfe648e6fa56df2b634ae04cfee7f8">HTTPResponse::CacheType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a5c4373e43d9720c8ad8feec3743ba66a">cache_type</a></td></tr>
<tr class="memdesc:a5c4373e43d9720c8ad8feec3743ba66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">캐쉬의 타입을 저장하는 멤버  <a href="#a5c4373e43d9720c8ad8feec3743ba66a"></a><br/></td></tr>
<tr class="memitem:a6871841bf2ed753e10ad0c62760dd747"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a6871841bf2ed753e10ad0c62760dd747">db_id</a></td></tr>
<tr class="memdesc:a6871841bf2ed753e10ad0c62760dd747"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqlite 데이터베이스에서의 유니크아이디  <a href="#a6871841bf2ed753e10ad0c62760dd747"></a><br/></td></tr>
<tr class="memitem:a9d118471aef143354ad3116826c595c2"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a9d118471aef143354ad3116826c595c2">db_expires</a></td></tr>
<tr class="memdesc:a9d118471aef143354ad3116826c595c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqlite 데이터베이스에서의 이전요청(같은 URL)에대한 응답헤더에 담긴 Expires를 time_t 스트럭트값으로 변경한 값  <a href="#a9d118471aef143354ad3116826c595c2"></a><br/></td></tr>
<tr class="memitem:a3c347cc02120eb3a91b86077c523bc7a"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a3c347cc02120eb3a91b86077c523bc7a">db_last_modified</a></td></tr>
<tr class="memdesc:a3c347cc02120eb3a91b86077c523bc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sqlite 데이터베이스에서의 이전요청(같은 URL)에대한 응답헤더에 담긴 Last-Modified를 time_t 스트럭트값으로 변경한 값  <a href="#a3c347cc02120eb3a91b86077c523bc7a"></a><br/></td></tr>
<tr class="memitem:a4c0b7fe9c8cbc26672d8a4061135891e"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a4c0b7fe9c8cbc26672d8a4061135891e">expires</a></td></tr>
<tr class="memdesc:a4c0b7fe9c8cbc26672d8a4061135891e"><td class="mdescLeft">&#160;</td><td class="mdescRight">이 인스턴스가 처리중인 응답에대한 헤더의 Expires값을 time_t 구조체로 변경한값  <a href="#a4c0b7fe9c8cbc26672d8a4061135891e"></a><br/></td></tr>
<tr class="memitem:a025de0dca06f8a6d2df0b8cbdf0fa3f8"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a025de0dca06f8a6d2df0b8cbdf0fa3f8">last_modified</a></td></tr>
<tr class="memdesc:a025de0dca06f8a6d2df0b8cbdf0fa3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">이 인스턴스가 처리중인 응답에대한 헤더의 Last-Modified값을 time_t 구조체로 변경한값  <a href="#a025de0dca06f8a6d2df0b8cbdf0fa3f8"></a><br/></td></tr>
<tr class="memitem:ac52711e80e376535da9537778bda60f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ac52711e80e376535da9537778bda60f2">paused</a></td></tr>
<tr class="memdesc:ac52711e80e376535da9537778bda60f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청처리에대한 일시정지 FLAG  <a href="#ac52711e80e376535da9537778bda60f2"></a><br/></td></tr>
<tr class="memitem:a8460f369ad03be980466cd4691c5160a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a8460f369ad03be980466cd4691c5160a">tag</a></td></tr>
<tr class="memdesc:a8460f369ad03be980466cd4691c5160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에대한 TAG값  <a href="#a8460f369ad03be980466cd4691c5160a"></a><br/></td></tr>
<tr class="memitem:a06610589e4c0fe374656b3f4b443ceeb"><td class="memItemLeft" align="right" valign="top">CURL *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a06610589e4c0fe374656b3f4b443ceeb">curl</a></td></tr>
<tr class="memdesc:a06610589e4c0fe374656b3f4b443ceeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청을 처리할수 있는 curl 인스턴스  <a href="#a06610589e4c0fe374656b3f4b443ceeb"></a><br/></td></tr>
<tr class="memitem:a9ec2161cb6e4206aefae14f1763c2bd4"><td class="memItemLeft" align="right" valign="top">struct curl_slist *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a9ec2161cb6e4206aefae14f1763c2bd4">header_chunk</a></td></tr>
<tr class="memdesc:a9ec2161cb6e4206aefae14f1763c2bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청헤더를 만드는 curl 인스턴스  <a href="#a9ec2161cb6e4206aefae14f1763c2bd4"></a><br/></td></tr>
<tr class="memitem:ab29feabc537062277a3e9b3ec23f874a"><td class="memItemLeft" align="right" valign="top">struct curl_httppost *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ab29feabc537062277a3e9b3ec23f874a">http_post</a></td></tr>
<tr class="memdesc:ab29feabc537062277a3e9b3ec23f874a"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청바디를 만드는 curl 인스턴스  <a href="#ab29feabc537062277a3e9b3ec23f874a"></a><br/></td></tr>
<tr class="memitem:a2176baedf3c965ec076089e3e4e338a2"><td class="memItemLeft" align="right" valign="top">struct curl_httppost *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a2176baedf3c965ec076089e3e4e338a2">last_post</a></td></tr>
<tr class="memdesc:a2176baedf3c965ec076089e3e4e338a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청바디를 만드는 curl 인스턴스  <a href="#a2176baedf3c965ec076089e3e4e338a2"></a><br/></td></tr>
<tr class="memitem:ac892f336c6b4da2ba35852524fce59a7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ac892f336c6b4da2ba35852524fce59a7">header_file_path</a></td></tr>
<tr class="memdesc:ac892f336c6b4da2ba35852524fce59a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답의 헤더를 저장할 임시파일의 경로입니다.  <a href="#ac892f336c6b4da2ba35852524fce59a7"></a><br/></td></tr>
<tr class="memitem:a351cc242b4d697d55d69d6d30694ac1a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a351cc242b4d697d55d69d6d30694ac1a">body_file_path</a></td></tr>
<tr class="memdesc:a351cc242b4d697d55d69d6d30694ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답의 바디를 저장할 임시파일의 경로입니다.  <a href="#a351cc242b4d697d55d69d6d30694ac1a"></a><br/></td></tr>
<tr class="memitem:a1bed244435d0285b422ad2be3e80c582"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a1bed244435d0285b422ad2be3e80c582">cache_header_file_path</a></td></tr>
<tr class="memdesc:a1bed244435d0285b422ad2be3e80c582"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답헤더를 캐쉬할 파일의 경로입니다.  <a href="#a1bed244435d0285b422ad2be3e80c582"></a><br/></td></tr>
<tr class="memitem:ae2f3e2f100ccb1e9ab41fccd512d25f3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ae2f3e2f100ccb1e9ab41fccd512d25f3">cache_body_file_path</a></td></tr>
<tr class="memdesc:ae2f3e2f100ccb1e9ab41fccd512d25f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답바디를 캐쉬할 파일의 경로입니다.  <a href="#ae2f3e2f100ccb1e9ab41fccd512d25f3"></a><br/></td></tr>
<tr class="memitem:a0db5dbe34a8d5ee16c2c54f540f5d3e9"><td class="memItemLeft" align="right" valign="top">std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a0db5dbe34a8d5ee16c2c54f540f5d3e9">header</a></td></tr>
<tr class="memdesc:a0db5dbe34a8d5ee16c2c54f540f5d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답헤더를 쓸 파일스트림입니다.  <a href="#a0db5dbe34a8d5ee16c2c54f540f5d3e9"></a><br/></td></tr>
<tr class="memitem:a3e6e07139e9c9ccee4f4dfae33b81f60"><td class="memItemLeft" align="right" valign="top">std::ofstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#a3e6e07139e9c9ccee4f4dfae33b81f60">body</a></td></tr>
<tr class="memdesc:a3e6e07139e9c9ccee4f4dfae33b81f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청에 대한 응답바디를 쓸 파일스트림입니다.  <a href="#a3e6e07139e9c9ccee4f4dfae33b81f60"></a><br/></td></tr>
<tr class="memitem:ad34d3f3134c50301c73b5d58262bbe87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_t_t_p_event.html">HTTPEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#ad34d3f3134c50301c73b5d58262bbe87">event</a></td></tr>
<tr class="memdesc:ad34d3f3134c50301c73b5d58262bbe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTTP_cpp 를 사용하는 개발자에게 Event를 보내기 위한 주소값입니다.  <a href="#ad34d3f3134c50301c73b5d58262bbe87"></a><br/></td></tr>
<tr class="memitem:afaec37c59c1da59fc44206aef5d5f348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_h_t_t_p_request.html">HTTPRequest</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_h_t_t_p_client.html#afaec37c59c1da59fc44206aef5d5f348">request</a></td></tr>
<tr class="memdesc:afaec37c59c1da59fc44206aef5d5f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">요청을 저장하기 위한 멤버변수 입니다.  <a href="#afaec37c59c1da59fc44206aef5d5f348"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>상세한 설명</h2>
<div class="textblock"><p>내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다. </p>
<p><a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 는 libcurl과 파일스트림을 이용하여 요청에 대한 응답처리를 합니다.</p>
<p>또한 캐싱을 할건지 말건지에대한 판단또한 합니다.</p>
<p>HTTP_cpp 에서는 캐쉬의 판단에 있어서 Expires와 Last-Modified만 지원합니다.</p>
<p>Expires,Last-Modified에 대한 참고링크 <a href="http://mytory.co.kr/archives/1232">http://mytory.co.kr/archives/1232</a> </p>
</div><hr/><h2>생성자 &amp; 소멸자 문서화</h2>
<a class="anchor" id="a26860227a4605fc5be92e2cb38486f7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HTTPClient::HTTPClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_h_t_t_p_event.html">HTTPEvent</a> *&#160;</td>
          <td class="paramname"><em>_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_h_t_t_p_request.html">HTTPRequest</a>&#160;</td>
          <td class="paramname"><em>_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>생성자 </p>
<p><a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 를 만들기위한 생성자 입니다. HTTP_cpp 는 HTTP_cpp 를 사용하는 개발자가 <a class="el" href="class_h_t_t_p_event.html#ab8937670a6c582230458452b4969536d" title="해당 태그로 자정된 요청을보냅니다.(연결 만들기)">HTTPEvent::Send</a> 함수를 호출하였을때 이 생생자를 이용하여 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 를 생성합니다. libcurl 인스턴스(요청처리를 위함) 및 파일스트림(응답처리 및 캐쉬를 위함), sqlite 엔트리(캐쉬를 위함), sqlite 쿼리(캐쉬를 위함) 등이 준비되며, 이때 첫번째로는 HTTPManager::_AddClient 가 호출되어 <a class="el" href="class_h_t_t_p_manager.html" title="HTTPEvent 들을 관리하는 Singleton Class.">HTTPManager</a> 에 요청이 등록됩니다. 두번째로는 HTTPEvent::_AddClient 가 호출되어 이벤트리스트에 등록됩니다.</p>
<dl class="params"><dt>매개변수:</dt><dd>
  <table class="params">
    <tr><td class="paramname">_event</td><td>HTTP_cpp 를 사용하는 개발자에게 event( HTTPEvent::Recieve , HTTPEvent::Error , HTTPEvent::Progress )를 보내기 위한 <a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> 인스턴스 주소값 </td></tr>
    <tr><td class="paramname">_tag</td><td><a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> 에서 Event가 발생하였을때 어떤요청에 대한 Event인지를 판단하기위한 태그값 </td></tr>
    <tr><td class="paramname">_request</td><td>요청에대한 정보 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97467b9bd9469200fb5266ae3622acc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HTTPClient::~HTTPClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>소멸자 </p>
<p><a class="el" href="class_h_t_t_p_manager.html" title="HTTPEvent 들을 관리하는 Singleton Class.">HTTPManager</a> 에서 요청에 대한 응답처리가 끝나면 이 소멸자를 호출합니다. 또한 이소멸자는 호출되며 첫번째로는 HTTPManager::_RemoveClient 를 호출하여 요청을 처리할 리스트에서 삭제됩니다. 두번째로는 HTTPEvent::_RemoveClient 가 호출되어 이벤트리스트에서도 삭제됩니다. </p>

</div>
</div>
<hr/><h2>멤버 함수 문서화</h2>
<a class="anchor" id="ab435bd9c4485fb2d8860d821e598b27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CURL * HTTPClient::GetCURL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>libcurl 인스턴스를 가져오는 함수입니다. </p>

</div>
</div>
<a class="anchor" id="ad2e70df1d9aa350e6666808d56d74ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string HTTPClient::GetTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>어떤요청에 대한 응답인가를 구분하기위한 태그를 가져오기위한 함수입니다. </p>

</div>
</div>
<a class="anchor" id="a292f406c40b3d2ccaf91b83fe9a3616c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HTTPClient::MessageReciever </td>
          <td>(</td>
          <td class="paramtype">CURLcode&#160;</td>
          <td class="paramname"><em>_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>응답이 처리된 결과를 <a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> (개발자가 생성한 클래스) 에게 전달하는 함수입니다. </p>
<p><a class="el" href="class_h_t_t_p_manager.html#a688eb551b475720abf1e3643a40c74fa" title="HTTPEvent 요청에 대한 응답을 기다리고 응답이 있으면 처리합니다.">HTTPManager::Update</a> 함수가 호출될때 작동됩니다.</p>
<p>libcurl에서 응답처리 메세지가 호출되었을때 작동하며 이후 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 인스턴스는 삭제됩니다. </p>

</div>
</div>
<a class="anchor" id="a11a02d3946f51d593310d0c529621d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HTTPClient::Pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>연결을 일시중지 합니다. </p>
<dl class="params"><dt>매개변수:</dt><dd>
  <table class="params">
    <tr><td class="paramname">이미</td><td>일시중지가 되어있다면 false를 리턴합니다. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bb2704835eb0fc23b714a5e0ce76fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HTTPClient::PrevUpdateAndGetNeedDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>이함수는 <a class="el" href="class_h_t_t_p_manager.html#a688eb551b475720abf1e3643a40c74fa" title="HTTPEvent 요청에 대한 응답을 기다리고 응답이 있으면 처리합니다.">HTTPManager::Update</a> 때 필요한 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 의 작동을 위한 함수입니다. </p>
<p>이함수는 캐싱처리를 위한 함수입니다.</p>
<p><a class="el" href="class_h_t_t_p_manager.html#a688eb551b475720abf1e3643a40c74fa" title="HTTPEvent 요청에 대한 응답을 기다리고 응답이 있으면 처리합니다.">HTTPManager::Update</a> 함수가 호출될때 작동됩니다.</p>
<p>캐싱처리를 할때는 더이상 연결이 필요하지 않음으로 libcurl에서 메세지가 오지않아도 이함수에서 바로 <a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> 로 응답처리결과를 알려주며, 처리가 끝난 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 는 더이상 필요하지 않기때문에 삭제를 해야할지 말아야할지를 <a class="el" href="class_h_t_t_p_manager.html" title="HTTPEvent 들을 관리하는 Singleton Class.">HTTPManager</a> 에게 돌려줍니다. 이후 <a class="el" href="class_h_t_t_p_manager.html#a688eb551b475720abf1e3643a40c74fa" title="HTTPEvent 요청에 대한 응답을 기다리고 응답이 있으면 처리합니다.">HTTPManager::Update</a> 에서 소멸자를 호출하여 인스턴스를 삭제합니다. </p>

</div>
</div>
<a class="anchor" id="a42a26707682633205202d0916ece0102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HTTPClient::Progress </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_client_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_download_total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_download_now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_upload_total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>_upload_now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청 또는 응답의 진행상태를 가져오는 콜백함수 </p>
<p>이함수는 2가지 일을합니다.</p>
<p>첫번째로는 libcurl은 이콜백함수를 이용하여 요청의 전송상태와 응답의 전송상태를 확인합니다.이 함수는 내부적으로 <a class="el" href="class_h_t_t_p_event.html#ab23948f0e84d047c5d1ccb8c8d840548" title="응답받거나 요청보낸 데이터의 진행률">HTTPEvent::Progress</a> 에 값이 전달됩니다.</p>
<p>두번째로는 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 가 일시중지 상태인지 연결상태인지를 판단해 libcurl에 알맞게 작동되도록 libcurl의 함수인 curl_easy_pause를 실행합니다.(curl_easy_pause에 대한 링크: <a href="http://curl.haxx.se/libcurl/c/curl_easy_pause.html">http://curl.haxx.se/libcurl/c/curl_easy_pause.html</a> )</p>
<p>이 콜백에 대한 참고링크 <a href="http://stackoverflow.com/questions/1637587/c-libcurl-console-progress-bar">http://stackoverflow.com/questions/1637587/c-libcurl-console-progress-bar</a> </p>

</div>
</div>
<a class="anchor" id="a9bbd082e51409e3bfe75cbf6d85c4a74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t HTTPClient::ReadBody </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답의 바디를 저장하는 콜백함수 </p>
<p>libcurl은 이콜백함수를 이용하여 std::ofstream 형태의 멤버변수인 body 에 요청에대한 응답의 바디를 저장합니다.</p>
<p>이 콜백에 대한 참고링크 <a href="http://stackoverflow.com/questions/2329571/c-libcurl-get-output-into-a-string">http://stackoverflow.com/questions/2329571/c-libcurl-get-output-into-a-string</a> </p>

</div>
</div>
<a class="anchor" id="a0c2611e4df1de68e2b556d07a39bdc11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t HTTPClient::ReadHeader </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답의 헤더를 저장하는 콜백함수 </p>
<p>libcurl은 이콜백함수를 이용하여 std::ofstream 형태의 멤버변수인 header 에 요청에대한 응답의 헤더를 저장합니다.</p>
<p>이 콜백에 대한 참고링크 <a href="http://blog.naver.com/PostView.nhn?blogId=ycw002&logNo=20062219296">http://blog.naver.com/PostView.nhn?blogId=ycw002&amp;logNo=20062219296</a> </p>

</div>
</div>
<a class="anchor" id="a036d48e160ef6b9ec60f53a27e71efde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HTTPClient::ReadyBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>인스턴스를 생성할때 호출되는 요청바디 준비함수 입니다. </p>
<p>libcurl의 함수를 이용하여 요청바디를 만들어냅니다.</p>
<p>libcurl의 요청바디 만들기 함수링크 <a href="http://curl.haxx.se/libcurl/c/curl_formadd.html">http://curl.haxx.se/libcurl/c/curl_formadd.html</a> </p>

</div>
</div>
<a class="anchor" id="a5c4bbb32ffa729f09442597b70655d9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HTTPClient::ReadyFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>인스턴스를 생성할때 호출되는 파일스트림 준비함수 입니다. </p>
<p>디버그 모드에서는 <a class="el" href="_h_t_t_p_config_8h.html" title="HTTP관련 환경 설정및 매크로">HTTPConfig.h</a> 에 지정한 경로가 권한이 없는경우 프로그램이 중단됩니다. 이를 막기위해서는 <a class="el" href="_h_t_t_p_config_8h.html" title="HTTP관련 환경 설정및 매크로">HTTPConfig.h</a> 의 HTTP_DEBUG 매크로를 변경하세요 </p>

</div>
</div>
<a class="anchor" id="a71aba6342097c8901d0f23deec079386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HTTPClient::ReadyHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>인스턴스를 생성할때 호출되는 요청해더 준비함수 입니다. </p>
<p>libcurl의 함수를 이용하여 요청해더를 만들어냅니다.</p>
<p>libcurl의 요청헤더 만들기 함수링크 <a href="http://curl.haxx.se/libcurl/c/curl_slist_append.html">http://curl.haxx.se/libcurl/c/curl_slist_append.html</a> </p>

</div>
</div>
<a class="anchor" id="ace4da074eb433e490c291fcbf5ca76c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HTTPClient::Resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>연결을 일시중지상태에서 빠져나옵니다. </p>
<dl class="params"><dt>매개변수:</dt><dd>
  <table class="params">
    <tr><td class="paramname">일시중지상태가</td><td>아니었다면 false를 리턴합니다. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32acff1743076dcf79a8a652a37a4afa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HTTPClient::SQLMatchURLCallback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_field_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>_field_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>보내려는 요청값과 같은 이전요청(같은 URL)이 있나를 검색하는 sqlite콜백 </p>
<p>값을 찾았을 경우 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 의 멤버변수인 db_id , db_expires , db_last_modified 를 설정한다.</p>
<p>이콜백에 대한 참고링크 <a href="http://six605.tistory.com/300">http://six605.tistory.com/300</a> </p>

</div>
</div>
<a class="anchor" id="afd834a35837d4fdf7a8aef71b545363c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HTTPClient::UpdateDB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sqlite 데이터베이스를 업데이트하는 함수입니다. </p>
<p>이 함수는 응답처리후 이후 캐쉬를 위해 정보를 데이터베이스에 저장합니다.(INSERT OR REPLACE: sqlite 쿼리인 INSERT OR REPLACE에 대한 링크 <a href="http://forums.fedoraforum.org/showthread.php?t=213737">http://forums.fedoraforum.org/showthread.php?t=213737</a> )</p>
<p>이함수가 호출되는 시점은 요청에대한 응답을 처리하기 바로 직전입니다.</p>
<dl class="section return"><dt>반환값:</dt><dd>이함수가 만약 데이터베이스에 데이터를 업데이트하거나 추가할경우 true가 반환되며 아닐경우 false를 리턴합니다. 업데이트할지 추가할지, 아니면 아무것도 안할지의 판단은 이 함수내에 캐싱에대한 판단에 따릅니다. </dd></dl>

</div>
</div>
<hr/><h2>멤버 데이타 문서화</h2>
<a class="anchor" id="a3e6e07139e9c9ccee4f4dfae33b81f60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream HTTPClient::body</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답바디를 쓸 파일스트림입니다. </p>
<p>이 스트림은 body_file_path 로 저장되며 응답처리가 끝난후 캐싱을 할 필요가 있다면 cache_body_file_path 로 경로가 변경됩니다. </p>

</div>
</div>
<a class="anchor" id="a351cc242b4d697d55d69d6d30694ac1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::body_file_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답의 바디를 저장할 임시파일의 경로입니다. </p>
<p>이경로로 생성된 파일은 응답처리후 삭제됩니다. </p>

</div>
</div>
<a class="anchor" id="ae2f3e2f100ccb1e9ab41fccd512d25f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::cache_body_file_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답바디를 캐쉬할 파일의 경로입니다. </p>
<p>이경로로 생성된 파일은 삭제되지 않습니다.삭제는 <a class="el" href="class_h_t_t_p_manager.html#a10be8b955f79ef82d96bb55018951003">HTTPManager::CleanCache</a> 를 이용하여야 합니다. </p>

</div>
</div>
<a class="anchor" id="a1bed244435d0285b422ad2be3e80c582"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::cache_header_file_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답헤더를 캐쉬할 파일의 경로입니다. </p>
<p>이경로로 생성된 파일은 삭제되지 않습니다.삭제는 <a class="el" href="class_h_t_t_p_manager.html#a10be8b955f79ef82d96bb55018951003">HTTPManager::CleanCache</a> 를 이용하여야 합니다. </p>

</div>
</div>
<a class="anchor" id="a5c4373e43d9720c8ad8feec3743ba66a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_t_t_p_response.html#af2cfe648e6fa56df2b634ae04cfee7f8">HTTPResponse::CacheType</a> HTTPClient::cache_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>캐쉬의 타입을 저장하는 멤버 </p>
<p><a class="el" href="class_h_t_t_p_response.html#af2cfe648e6fa56df2b634ae04cfee7f8aa866703cc8c9c7c10c0ae3f427023fc0">HTTPResponse::CacheType_None</a> : 요청시 보낼 URL이 처음 요청이거나, Expires가 만료되었거나</p>
<p><a class="el" href="class_h_t_t_p_response.html#af2cfe648e6fa56df2b634ae04cfee7f8a66f3a074e56236ec7fdd5301080686a5">HTTPResponse::CacheType_Last_Modified</a> : 요청시 보낼 URL이 이미 보냈었던 요청이고, Expires가 만료되었을때</p>
<p><a class="el" href="class_h_t_t_p_response.html#af2cfe648e6fa56df2b634ae04cfee7f8af3c308661ec806ff4981439f53cd98d1">HTTPResponse::CacheType_Expires</a> : 요청시 보낼 URL이 이미 보냈었던 요청이고, Expires가 만료되지 않았을때 </p>

</div>
</div>
<a class="anchor" id="a06610589e4c0fe374656b3f4b443ceeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CURL* HTTPClient::curl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청을 처리할수 있는 curl 인스턴스 </p>
<p>HTTP_cpp 는 내부적으로 요청처리에 libcurl을 사용합니다. 멤버변수 curl 은 이를위한 curl 기본 인스턴스 입니다. </p>

</div>
</div>
<a class="anchor" id="a9d118471aef143354ad3116826c595c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t HTTPClient::db_expires</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sqlite 데이터베이스에서의 이전요청(같은 URL)에대한 응답헤더에 담긴 Expires를 time_t 스트럭트값으로 변경한 값 </p>
<p>이 값은 인스턴스 초기화때 설정됩니다. 이기간이 만료되기 전까지는 요청도 보내지 않고(서버에서 확인하지 않고) 바로 캐쉬파일을 이용하여 응답을 임의로 발생시킵니다. </p>

</div>
</div>
<a class="anchor" id="a6871841bf2ed753e10ad0c62760dd747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::db_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sqlite 데이터베이스에서의 유니크아이디 </p>
<p>캐쉬파일의 파일이름으로도 사용된다. </p>

</div>
</div>
<a class="anchor" id="a3c347cc02120eb3a91b86077c523bc7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t HTTPClient::db_last_modified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sqlite 데이터베이스에서의 이전요청(같은 URL)에대한 응답헤더에 담긴 Last-Modified를 time_t 스트럭트값으로 변경한 값 </p>
<p>이 값은 인스턴스 초기화때 설정됩니다. Expires가 만료되었거나 Expires가 존재하지 않는경우 캐싱판단에 이 값이 사용됩니다. 요청에대한 서버의 응답을 확인하는중에 헤더를 파싱하고 파싱된값중에 Last-Modified가 이전에 받은 응답(sqlite 데이터베이스에저장)인 이 멤버변수와 비교과정을 거쳐 응답바디를 full response할 것인지 캐쉬파일을 사용할것인지 결정합니다. </p>

</div>
</div>
<a class="anchor" id="ad34d3f3134c50301c73b5d58262bbe87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_t_t_p_event.html">HTTPEvent</a>* HTTPClient::event</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>HTTP_cpp 를 사용하는 개발자에게 Event를 보내기 위한 주소값입니다. </p>
<p>개발자가 <a class="el" href="class_h_t_t_p_event.html#ab8937670a6c582230458452b4969536d" title="해당 태그로 자정된 요청을보냅니다.(연결 만들기)">HTTPEvent::Send</a> 함수호출시 사용된 <a class="el" href="class_h_t_t_p_event.html" title="이클래스는 HTTP요청을 보낼수 있고 받을수 있는 이벤트핸들러입니다.">HTTPEvent</a> 메모리주소는 이 멤버변수에 저장됩니다. </p>

</div>
</div>
<a class="anchor" id="a4c0b7fe9c8cbc26672d8a4061135891e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t HTTPClient::expires</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>이 인스턴스가 처리중인 응답에대한 헤더의 Expires값을 time_t 구조체로 변경한값 </p>
<p>이 값은 요청에대한 응답을처리할때(헤더를 읽어들일때) 설정됩니다. 이값은 이후 다음번 캐싱에대한 판단을 위해 sqlite 데이터베이스에 저장됩니다. 다음요청(같은 URL)부터는 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 의 멤버변수인 db_expires 로 읽혀지고 캐싱판단에 사용됩니다. </p>

</div>
</div>
<a class="anchor" id="a0db5dbe34a8d5ee16c2c54f540f5d3e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ofstream HTTPClient::header</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답헤더를 쓸 파일스트림입니다. </p>
<p>이 스트림은 header_file_path 로 저장되며 응답처리가 끝난후 캐싱을 할 필요가 있다면 cache_header_file_path 로 경로가 변경됩니다. </p>

</div>
</div>
<a class="anchor" id="a9ec2161cb6e4206aefae14f1763c2bd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct curl_slist* HTTPClient::header_chunk</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청헤더를 만드는 curl 인스턴스 </p>
<p>HTTP_cpp 는 내부적으로 요청처리에 libcurl을 사용합니다. 멤버변수 header_chunk 는 이를위한 curl 인스턴스 입니다. </p>

</div>
</div>
<a class="anchor" id="ac892f336c6b4da2ba35852524fce59a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::header_file_path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에 대한 응답의 헤더를 저장할 임시파일의 경로입니다. </p>
<p>이경로로 생성된 파일은 응답처리후 삭제됩니다. </p>

</div>
</div>
<a class="anchor" id="ab29feabc537062277a3e9b3ec23f874a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct curl_httppost* HTTPClient::http_post</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청바디를 만드는 curl 인스턴스 </p>
<p>HTTP_cpp 는 내부적으로 요청처리에 libcurl을 사용합니다. 멤버변수 http_post 는 이를위한 curl 인스턴스 입니다. 멤버변수 http_post 는 last_post 와 함께 요청바디를 만듭니다. </p>

</div>
</div>
<a class="anchor" id="a025de0dca06f8a6d2df0b8cbdf0fa3f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time_t HTTPClient::last_modified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>이 인스턴스가 처리중인 응답에대한 헤더의 Last-Modified값을 time_t 구조체로 변경한값 </p>
<p>이 값은 요청에대한 응답을처리할때(헤더를 읽어들일때) 설정됩니다. 이값은 이후 다음번 캐싱에대한 판단을 위해 sqlite 데이터베이스에 저장됩니다. 다음요청(같은 URL)부터는 <a class="el" href="class_h_t_t_p_client.html" title="내부적인 Request + Response 유닛이며 실제로 HTTP_cpp 를 이용하는 개발자가 이클래스를 사용할일은 없습니다.">HTTPClient</a> 의 멤버변수인 db_last_modified 로 읽혀지고 캐싱판단에 사용됩니다. </p>

</div>
</div>
<a class="anchor" id="a2176baedf3c965ec076089e3e4e338a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct curl_httppost* HTTPClient::last_post</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청바디를 만드는 curl 인스턴스 </p>
<p>HTTP_cpp 는 내부적으로 요청처리에 libcurl을 사용합니다. 멤버변수 last_post 는 이를위한 curl 인스턴스 입니다. 멤버변수 last_post 는 http_post 와 함께 요청바디를 만듭니다. </p>

</div>
</div>
<a class="anchor" id="ac52711e80e376535da9537778bda60f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HTTPClient::paused</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청처리에대한 일시정지 FLAG </p>
<p>HTTP_cpp 는 요청에대한 응답처리를 일시정지할수 있습니다. 그와 반대로 일시정지 상태를 다시 응답처리상태로 활성화 할 수도 있습니다. 그에대한 FLAG값입니다. </p>

</div>
</div>
<a class="anchor" id="afaec37c59c1da59fc44206aef5d5f348"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_h_t_t_p_request.html">HTTPRequest</a> HTTPClient::request</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청을 저장하기 위한 멤버변수 입니다. </p>
<p>개발자가 <a class="el" href="class_h_t_t_p_event.html#ab8937670a6c582230458452b4969536d" title="해당 태그로 자정된 요청을보냅니다.(연결 만들기)">HTTPEvent::Send</a> 함수호출시 사용된 <a class="el" href="class_h_t_t_p_request.html">HTTPRequest</a> 변수는 이 멤버변수에 저장됩니다. </p>

</div>
</div>
<a class="anchor" id="a8460f369ad03be980466cd4691c5160a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HTTPClient::tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>요청에대한 TAG값 </p>
<p>이 값은 요청에대한 응답이 개발자에게 갔을때 그 응답이 어떤요청에 대한 응답인지 쉽게 판단할수 있도록 하게하기위한 std::string 값 태그입니다. 이값은 요청에대한 응답이 처리되고 난뒤에 <a class="el" href="class_h_t_t_p_event.html#a1813ea9db674b3b0a97d0d586ce5f6d8" title="응답받기(이후 연결은 제거됩니다.) 추상화 함수입니다.">HTTPEvent::Receive</a> , <a class="el" href="class_h_t_t_p_event.html#a5e1a758003e696b19c26d071f63b2bd5" title="응답 에러(이후 연결은 제거 됩니다.) 추상화 함수입니다.">HTTPEvent::Error</a> , <a class="el" href="class_h_t_t_p_event.html#ab23948f0e84d047c5d1ccb8c8d840548" title="응답받거나 요청보낸 데이터의 진행률">HTTPEvent::Progress</a> 등으로 전달됩니다. </p>

</div>
</div>
<hr/>이 클래스에 대한 문서화 페이지는 다음의 파일들로부터 생성되었습니다.:<ul>
<li><a class="el" href="_h_t_t_p_client_8h_source.html">HTTPClient.h</a></li>
<li><a class="el" href="_h_t_t_p_client_8cpp.html">HTTPClient.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_h_t_t_p_client.html">HTTPClient</a></li>
    <li class="footer">생성시간 : 목 7월 12 2012 20:16:11, 프로젝트명 : HTTP_cpp, 생성자 : 
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
